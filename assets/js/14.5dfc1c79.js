(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{514:function(t,v,_){t.exports=_.p+"assets/img/image-33.d216e17e.png"},540:function(t,v,_){"use strict";_.r(v);var s=_(2),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"js垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js垃圾回收机制"}},[t._v("#")]),t._v(" JS垃圾回收机制")]),t._v(" "),s("blockquote",[s("p",[t._v("参考博客（https://juejin.cn/post/6981588276356317214）")])]),t._v(" "),s("p",[t._v("垃圾回收是一种自动的内存资源管理机制，当对象不再被引用到或者不能从根上访问到，就会判定位垃圾")]),t._v(" "),s("p",[t._v("常见的算法：引用计数，标记清除，标记整理，分代回收")]),t._v(" "),s("h3",{attrs:{id:"引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),s("p",[t._v("早期用的垃圾回收方法，用一张表保存内存里面所有资源的引用次数，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放")]),t._v(" "),s("p",[t._v("存在比较大的问题：无法回收"),s("strong",[t._v("循环引用")]),t._v("的对象（相互引用形成一个环，这样引用计数都不为0，就不会被回收），空间开销比较大（需要单独拿出一片空间去维护每个变量的引用计数）")]),t._v(" "),s("h3",{attrs:{id:"标记清除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),s("ol",[s("li",[t._v("从window开始遍历所有对象找"),s("strong",[t._v("标记")]),t._v("活动对象；")]),t._v(" "),s("li",[t._v("遍历所有对象"),s("strong",[t._v("清除")]),t._v("没有标记对象；")]),t._v(" "),s("li",[t._v("回收相应的空间。")])]),t._v(" "),s("p",[t._v("对比引用计数算法，标记清除算法最大的优点是能够回收循环引用的对象")]),t._v(" "),s("p",[t._v("缺点：会形成空间碎片化，被回收的空间不连续，导致不能被分配")]),t._v(" "),s("h3",{attrs:{id:"标记整理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记整理"}},[t._v("#")]),t._v(" 标记整理")]),t._v(" "),s("p",[t._v("为了解决内存碎片化的问题，提高对内存的利用，引入了标记整理算法")]),t._v(" "),s("p",[t._v("清除阶段会先执行整理，移动对象位置,将存活的对象移动到一边，然后再清理存活端边界外的内存")]),t._v(" "),s("p",[t._v("缺点：移动对象位置，不会立即回收对象，回收的效率比较慢")]),t._v(" "),s("h3",{attrs:{id:"分代回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[t._v("#")]),t._v(" 分代回收")]),t._v(" "),s("p",[t._v("V8 中将堆内存分为"),s("strong",[t._v("新生代和老生代")]),t._v("两个区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。")]),t._v(" "),s("p",[s("strong",[t._v("新生代")]),t._v("使用复制式的方法，将内存分成使用去和空闲区，新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作：将使用区的活动对象进行标记，标记完成之后复制进空闲区并且进行排序，随后将使用区非活动对象的空间清理掉，最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区")]),t._v(" "),s("p",[t._v("当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，或者对象复制后占比内存过大（超过空闲区的25%），都会被移动到老生代中，采用老生代的垃圾回收策略进行管理")]),t._v(" "),s("p",[s("strong",[t._v("老生代")]),t._v("执行的是标记整理算法")]),t._v(" "),s("p",[s("img",{attrs:{src:_(514),alt:"image-33"}})]),t._v(" "),s("h3",{attrs:{id:"性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),s("ul",[s("li",[t._v("避免使用全局变量")]),t._v(" "),s("li",[t._v("减少判断层级")]),t._v(" "),s("li",[t._v("减少数据读取次数，对于频繁使用的数据，我们要对数据进行缓存")]),t._v(" "),s("li",[t._v("减少循环体中的活动")])])])}),[],!1,null,null,null);v.default=a.exports}}]);