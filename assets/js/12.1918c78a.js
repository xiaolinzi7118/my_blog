(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{511:function(s,t,e){s.exports=e.p+"assets/img/websocket1.3c6097bd.png"},512:function(s,t,e){s.exports=e.p+"assets/img/websocket2.421b3126.png"},535:function(s,t,e){"use strict";e.r(t);var a=e(2),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"http-和-websocket-长连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-和-websocket-长连接"}},[s._v("#")]),s._v(" HTTP 和 Websocket 长连接")]),s._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/590817258",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考博客"),a("OutboundLink")],1)])]),s._v(" "),a("h3",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[s._v("#")]),s._v(" HTTP")]),s._v(" "),a("p",[s._v("前端发一次HTTP请求，网站返回一次HTTP响应，但这种情况下，服务器"),a("strong",[s._v("不会主动")]),s._v("给客户端发消息，为了解决用户不做任何操作的情况下，网页能接收到消息并发生变更，可以"),a("strong",[s._v("使用HTTP不断轮询")]),s._v("或者"),a("strong",[s._v("长轮询")])]),s._v(" "),a("p",[s._v("HTTP不断轮询：网页的前端代码不断定时发HTTP请求到服务器，服务器收到请求后给客户端响应消息。（场景：扫码登录）问题就是：F12界面会占满屏的HTTP请求，会消耗带宽以及增加下游服务器的负担；以及用户体验上扫码确认成功后，可能会等1~2s，才触发下一次HTTP请求后再跳转页面，会感到明显卡顿。")]),s._v(" "),a("p",[s._v("长轮询：发起一个请求，在较长时间内等待服务器响应的机制，比如扫码登录，把HTTP请求的超时限制延长（如30s），超时后立马发起下一次请求")]),s._v(" "),a("p",[s._v("这两种解决方案，本质上还是客户端主动去取数据")]),s._v(" "),a("h3",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[s._v("#")]),s._v(" Websocket")]),s._v(" "),a("p",[a("strong",[s._v("TCP")]),s._v("连接的两端，同一时间里双方都可以"),a("strong",[s._v("主动")]),s._v("向对方发送数据==>"),a("strong",[s._v("全双工")]),s._v("；HTTP基于TCP协议，但是设计之初考虑的是网页文本的场景，只做到客户端发齐请求再由服务器响应==>"),a("strong",[s._v("半双工")])]),s._v(" "),a("p",[s._v("基于TCP的新协议==>"),a("strong",[s._v("Websocket")]),s._v("，例如网页游戏，聊天，服务器和客户端需要频繁交互的场景。")]),s._v(" "),a("p",[s._v("浏览器在"),a("strong",[s._v("TCP三次握手")]),s._v("建立连接之后，都"),a("strong",[s._v("统一使用HTTP协议")]),s._v("先进行一次通信。")]),s._v(" "),a("ul",[a("li",[s._v("如果此时是"),a("strong",[s._v("普通的HTTP请求")]),s._v("，那后续双方就还是老样子继续用普通HTTP协议进行交互，这点没啥疑问。")]),s._v(" "),a("li",[s._v("如果这时候是"),a("strong",[s._v("想建立websocket连接")]),s._v("，就会在HTTP请求里带上一些"),a("strong",[s._v("特殊的header头")]),s._v("。")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("Connection"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" Upgrade "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 升级协议成websocket")]),s._v("\nUpgrade"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" websocket\nSec"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("WebSocket"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("Key"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" T2a6wZlAwhgQNqruZ2YUyg"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("\\r\\n "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 随机生成的base64码发给服务器")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("如果服务器支持，走websocket握手流程，把客户端生成的base64码经过公开算法响应101状态码（指协议切换）给客户端，之后，浏览器也用同样的"),a("strong",[s._v("公开算法")]),s._v("将"),a("code",[s._v("base64码")]),s._v("转成另一段字符串，如果这段字符串跟服务器传回来的"),a("strong",[s._v("字符串一致")]),s._v("，那验证通过")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("HTTP")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("101")]),s._v(" Switching Protocols\\r\\n\nSec"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("WebSocket"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("Accept"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" iBJKv"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("ALIW2DobfoA4dmr3JHBCY"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("\\r\\n\nUpgrade"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" websocket\\r\\n\nConnection"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" Upgrade\\r\\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[a("img",{attrs:{src:e(511),alt:"image"}})]),s._v(" "),a("p",[s._v("经历了一来一回两次HTTP握手，websocket就建立完成了，后续双方就可以使用webscoket的数据格式进行通信了")]),s._v(" "),a("p",[a("img",{attrs:{src:e(512),alt:"image"}})]),s._v(" "),a("p",[s._v("总之就是，websocket和HTTP一样都是基于TCP的协议。经历了三次TCP握手之后，利用HTTP协议升级为websocket协议建立连接。")]),s._v(" "),a("p",[a("strong",[s._v("代码中建立websocket")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" socket "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("WebSocket")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'ws://localhost:8080'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// socket有url,open,close,error,send等属性和方法")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("ul",[a("li",[s._v("TCP协议本身是"),a("strong",[s._v("全双工")]),s._v("的，但我们最常用的HTTP1.1，虽然是基于TCP的协议，但它是"),a("strong",[s._v("半双工")]),s._v("的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的websocket协议。")]),s._v(" "),a("li",[s._v("在HTTP1.1里。只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用"),a("strong",[s._v("定时轮询或者长轮询")]),s._v("的方式实现"),a("strong",[s._v("服务器推送")]),s._v("(comet)的效果。")]),s._v(" "),a("li",[s._v("对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用websocket协议。")]),s._v(" "),a("li",[s._v("websocket和socket几乎没有任何关系，只是叫法相似。")]),s._v(" "),a("li",[s._v("正因为各个浏览器都支持HTTP协议，所以websocket会先利用HTTP协议加上一些特殊的header头进行握手升级操作，升级成功后就跟HTTP没有任何关系了，之后就用websocket的数据格式进行收发数据。")]),s._v(" "),a("li",[s._v("websocket没有同源限制，因为websocket使用类似ws://这样的方式进行连接，并不是使用http协议进行数据传输。所以浏览器的SOP无法限制它。而且websocket本来就是设计成支持跨域访问的协议的。在websocket请求的请求头中会像cors一样加入origin字段，服务端可以根据这个字段来判断是否通过该请求")])])])}),[],!1,null,null,null);t.default=r.exports}}]);